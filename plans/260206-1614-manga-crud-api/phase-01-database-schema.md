# Phase 01: Database Schema & Migrations

**Status**: Pending | **Effort**: 1.5h | **Dependencies**: None | **Parallel**: Yes

## Objective

Replace placeholder `healthChecks` table with production manga schema:
- `manga` table (core entity)
- `genres` table (reference data)
- `manga_genres` junction table (many-to-many)
- Drizzle relations for type-safe joins
- Proper indexes (slug, FK, timestamps)

## File Ownership

**Exclusive writes** (no conflicts):
- `apps/api/src/db/schema.ts` — Replace entire file
- `apps/api/drizzle/*.sql` — Generated by drizzle-kit
- `apps/api/.env.example` — Add DATABASE_URL example (create if missing)

**Reads** (safe):
- `apps/api/src/db/client.ts` — Verify drizzle setup (no changes needed)

## Implementation Steps

### 1. Define Enums (in schema.ts)

```typescript
import { pgEnum } from 'drizzle-orm/pg-core'

export const mangaStatusEnum = pgEnum('manga_status', ['ongoing', 'completed', 'hiatus', 'cancelled'])
export const mangaTypeEnum = pgEnum('manga_type', ['manga', 'manhwa', 'manhua', 'one_shot', 'doujinshi'])
export const languageEnum = pgEnum('language', ['en', 'jp', 'ko', 'zh'])
```

### 2. Define Genres Table

```typescript
export const genres = pgTable('genres', {
  id: serial('id').primaryKey(),
  name: text('name').notNull().unique(),
  slug: text('slug').notNull().unique(),
  description: text('description'),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
})
```

**Indexes**: Unique on name + slug (enforced by .unique())

### 3. Define Manga Table

```typescript
export const manga = pgTable('manga', {
  id: serial('id').primaryKey(),
  title: text('title').notNull(),
  slug: text('slug').notNull().unique(),
  alternativeTitles: text('alternative_titles').array(), // text[]
  description: text('description'),
  author: text('author'),
  artist: text('artist'),
  coverImage: text('cover_image'),
  status: mangaStatusEnum('status').notNull().default('ongoing'),
  type: mangaTypeEnum('type').notNull().default('manga'),
  language: languageEnum('language').notNull().default('en'),
  releaseYear: integer('release_year'),
  rating: real('rating').default(0),
  views: integer('views').default(0),
  createdAt: timestamp('created_at').defaultNow().notNull(),
  updatedAt: timestamp('updated_at').defaultNow().notNull(),
}, (table) => ({
  slugIdx: index('manga_slug_idx').on(table.slug),
  statusIdx: index('manga_status_idx').on(table.status),
  typeIdx: index('manga_type_idx').on(table.type),
}))
```

**Indexes**: slug (unique), status, type (for filtering)

### 4. Define MangaGenres Junction Table

```typescript
export const mangaGenres = pgTable('manga_genres', {
  id: serial('id').primaryKey(),
  mangaId: integer('manga_id').notNull().references(() => manga.id, { onDelete: 'cascade' }),
  genreId: integer('genre_id').notNull().references(() => genres.id, { onDelete: 'cascade' }),
  createdAt: timestamp('created_at').defaultNow().notNull(),
}, (table) => ({
  mangaIdIdx: index('manga_genres_manga_id_idx').on(table.mangaId),
  genreIdIdx: index('manga_genres_genre_id_idx').on(table.genreId),
  uniquePair: unique('manga_genres_unique').on(table.mangaId, table.genreId),
}))
```

**Indexes**: FK indexes + unique constraint on (mangaId, genreId)

### 5. Define Drizzle Relations

```typescript
import { relations } from 'drizzle-orm'

export const mangaRelations = relations(manga, ({ many }) => ({
  genres: many(mangaGenres),
}))

export const genreRelations = relations(genres, ({ many }) => ({
  manga: many(mangaGenres),
}))

export const mangaGenreRelations = relations(mangaGenres, ({ one }) => ({
  manga: one(manga, {
    fields: [mangaGenres.mangaId],
    references: [manga.id],
  }),
  genre: one(genres, {
    fields: [mangaGenres.genreId],
    references: [genres.id],
  }),
}))
```

### 6. Generate & Apply Migration

```bash
cd apps/api
pnpm db:generate  # Creates drizzle/*.sql
pnpm db:push      # Applies to database
```

**Verify**: Check `drizzle/` folder for generated SQL files

### 7. Add ENV Example

Create `apps/api/.env.example`:
```
DATABASE_URL=postgresql://user:password@localhost:5432/mangafire
PORT=3000
CORS_ORIGIN=http://localhost:5173
```

## Success Criteria

- [ ] `schema.ts` contains 3 tables + 3 enums + 3 relation definitions
- [ ] Migration files generated in `apps/api/drizzle/`
- [ ] `pnpm db:push` completes without errors
- [ ] Tables visible in DB (use `pnpm db:studio` to verify)
- [ ] Indexes created on slug, status, type, FK columns
- [ ] Unique constraints enforced (slug, genre name, manga-genre pairs)

## Conflict Prevention

**No overlaps with Phase 02/03/04**:
- Phase 02 only touches `packages/shared/src/`
- Phase 03 only touches `apps/api/src/middleware/` and `apps/api/src/lib/`
- Phase 04 only touches `apps/api/src/routes/` and `apps/api/src/index.ts`

**Safe to run in parallel**: Yes

## Risk Mitigation

| Risk | Mitigation |
|------|------------|
| Missing DATABASE_URL | Check `.env` exists, add `.env.example` |
| Drizzle-kit version mismatch | Use exact version from package.json (0.20.0) |
| Migration conflicts (if DB not clean) | Document in success criteria: "Fresh DB or manual cleanup required" |
| Enum syntax errors | Test with `pnpm type-check` before generating migrations |

## Code Reference

**Import structure**:
```typescript
import { pgTable, serial, text, integer, real, timestamp, index, unique, pgEnum } from 'drizzle-orm/pg-core'
import { relations } from 'drizzle-orm'
```

**Full file location**: `apps/api/src/db/schema.ts`

## Next Phase

After completion, Phase 04 can reference schema tables via:
```typescript
import { manga, genres, mangaGenres } from '../db/schema'
```
